import random
import time
import math


from django import forms
from django.utils.crypto import salted_hmac
from django.utils.safestring import mark_safe


from .settings import ITERATIONS


class CaptchaWidget(forms.widgets.MultiWidget):
    """The captcha widget generates captcha questions and supplies them to the form

    Captcha questions are generated by the widget, and the required values put
    into a set of form fields. Captchas do not rely on any server-side state;
    instead the answer and the time it was generated are cryptographically
    hashed and then included in the form itself. Validation simply requires
    repeating the hashing and verifying that the hash has not expired.
    """
    def __init__(self, attrs=None):
        """Initialize the various widgets in this MultiWidget"""
        widgets = (
                forms.TextInput(attrs=attrs),
                forms.HiddenInput(),
                forms.HiddenInput()
                )
        super().__init__(widgets, attrs)

    def decompress(self, value):
        """Don't actually parse out the values, just get ours"""
        return self._values

    def format_output(self, rendered_widgets):
        """All we want to do is stick all the widgets together"""
        return ''.join(rendered_widgets)

    def render(self, name, value, attrs=None):
        """Override the render() method to replace value with our current values

        This approach is based on the approach that Django's PasswordInput
        widget uses to ensure that passwords are not re-rendered in forms,
        except instead of prohibiting initial values we set them to those for
        our generated captcha.
        """
        value = self._values
        return super().render(name, value, attrs)

    def generate_captcha(self):
        """Generated a fresh captcha

        This method randomly generates a simple captcha question. It then
        generates a timestamp for the current time, and signs the answer
        cryptographically to protect against tampering and replay attacks.
        """
        # Generate a fresh question
        self._question, answer = self._generate_question()

        # Get the current time, then sign the answer cryptographically
        timestamp = time.time()
        hashed = self.hash_answer(answer, timestamp)

        # Now stash all our values
        self._values = ['', timestamp, hashed]

    def _generate_question(self):
        """Generate a random arithmetic question

        This method randomly generates a simple addition, subtraction, or
        multiplication question with two integers between 1 and 10, and then
        returns both question (formatted as a string) and answer.
        """
        x = random.randint(1, 10)
        y = random.randint(1, 10)

        operator = random.choice(('+', '-', '*',))
        if operator == '+':
            answer = x + y
        elif operator == '-':
            # Ensure we'll get a non-negative answer
            if x < y:
                x, y = y, x
            answer = x - y
        else:
            # Multiplication is hard, make it easier
            x = math.ceil(x/2)
            y = math.ceil(y/2)

            answer = x * y
            # Use a prettied-up HTML multiplication character
            operator = '&times;'

        # Format the answer nicely, then mark it as safe so Django won't escape it
        question = '{} {} {}'.format(x, operator, y)
        return mark_safe(question), answer

    def hash_answer(self, answer, timestamp):
        """Cryptographically hash the answer with the provided timestamp

        This method allows the widget to securely generate time-sensitive
        signatures that will both prevent tampering with the answer as well as
        provide some protection against replay attacks by limiting how long a
        given signature is valid for. Using this same method, the field can
        validate the submitted answer against the signature also provided in
        the form.
        """
        # Ensure our values are string before we start hashing
        timestamp = str(timestamp)
        answer = str(answer)
        hashed = ''

        # Hashing multiple times increases the security of the signature
        for _ in range(ITERATIONS):
            # We use Django's own "salted HMAC" for cryptographic signatures
            hashed = salted_hmac(timestamp, answer).hexdigest()

        return hashed

